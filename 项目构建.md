### 	一、前言

自从2020开始入行前端行业以来，到目前也有三年之久了，中间大大小小做过的项目也有不少，接触过小程序、H5、后台管理系统，但是关于后台管理还没有自己独立从0开始搭建过，之前的都是借助ruoyi和vue-admin大神搭建好的基础模版上进行二次的业务开发，关于整体的布局、动态路由、权限控制不是很清晰、因此空闲时间决定自己从0开始进行搭建

### 二、初始化脚手架

​	从0开始搭建一个基础后台管理系统的模版「vue2.6全家桶 + element-ui」vue3已经出来很久了，尤大大也表示对vue2在2023年12月31日不在进行更新、全面推进vue3，而vue2.7同时也支持了CompositionAPI的写法，不过因为当时做的后台管理采用的是vue2.6的语法，目前这版是基于vue2.6的后台管理、后续想着在做一版「vue3 + vite + Pinia + element-ui 3.0」话不多说 直接开整！！！

​	基于@vue/cli 去创建的初始化应用，默认是3.x版本，选择2.x版本，vue全家桶「router、vuex、vuecli」+ less

### 三、目录规划

``` javascript
|-- public   // 公共资源
|   |--favicon.ico  // 站点图标 
|   |--index.html   // html模板「根节点」
|-- src      // 源代码「几乎业务逻辑代码都写在这个根目录下」
		|--apis				 // 请求api
		|--assets      // 存放静态资源
			 |--icons    // svg、icon图标
		|--components  // 存放公共组件
		|--durective   // 全局指令
		|--layout      // 布局
		|--router      // 路由
		|--store       // 全局状态管理「模块化」
		|--style       // 全局样式
		|--libs        // 公共方法库
			|--utils     // 工具类方法
      |--permission // 权限类方法
    |--views       // 视图
|-- App.vue        // 根组件
|-- main.js        // 入口文件
|-- .browerslistrc // 设置浏览器兼容性
|-- .editorconfig  // 代码格式
|-- .babel.config.js  // webpack的配置文件
|-- .babelrc       // babel-loader 配置
|-- eslintrc.js    // eslint 配置项
|-- .gitignore     // git 忽略项
|-- package.json   // package.json
```

以上目录也是基于vue-element-admin的目录结构进行整个项目的规划

### 四、安装第三方插件

``` js
axions          // 处理请求
element-ui      // ui组件库
js-cookie       // 持久化保存token
vuex-persistedstate  // vuex状态的持久化
```

> js-cookie 和 vuex-persistedstate都可以对vuex中的数据进行持久化保存 

### 五、封装request

​	规划好目录结构之后，我是先进行的axios封装、以及登录验证、其中涉及到了vuex模块化、token的持久化保存等

1.在src/utils创建request.js文件

``` javascript
import axios from 'axios';
import store from '@/store'
import { MessageBox, Message } from 'element-ui';
// 创建axios实例
const service = axios.create({
    baseURL: process.env.VUE_APP_BASE_API,
    timeout: 5000,
})
// 请求拦截器
service.interceptors.request.use(config => {
    // 判断是否携带token验证
    const isToken = (config.headers || {}).isToken === false;
    // vuex中的token 借用vuex-persistedstate 已经持久存储
    if (store.getters.token && !isToken) {
        config.headers['Authorization'] = 'Bearer ' + store.getters.token
    }
    return config
}, error => {
    // 处理错误的请求
    return Promise.reject(error);
})
// 响应拦截器
service.interceptors.response.use(response => {
    console.log("请求拦截:", store);
    // 不同的状态码，不同的处理
    // 401 登录时间过期
    const res = response.data,
        code = res.code || 200;
    if (code === 401) {
        MessageBox.confirm("登录状态已过期！请重新登陆哦", "系统提示", {
            confirmButtonText: "重新登陆",
            cancelButtonText: "取消",
            type: "warning"
        }).then(() => {
            // 调用登出接口，返回登录界面
            store.dispatch('Logout').then(() => {
                location.href = "/index";
            })
        });
        return Promise.reject('error')
    }
    if (code !== 200) {
        Message({
            message: res.msg || 'Error',
            type: 'error',
            duration: 5 * 1000
        })
        return Promise.reject(new Error(res.msg) || 'Error');
    }
    // 成功响应数据处理
    return res;
}, error => {
    // 不同的msg响应 对应的处理
    console.log('err' + error);
    let { message } = error;
    if (message == "Network Error") {
        message = "后端接口连接异常";
    } else if (message.includes("timeout")) {
        message = "系统接口请求超时";
    } else if (message.includes("Request failed with status code")) {
        message = "系统接口" + message.substr(message.length - 3) + "异常";
    }
    Message({
        message,
        type: 'error',
        duration: 5 * 1000
    })
    return Promise.reject(error);
})
export default service
```

2. vuex数据持久化保存

``` javascript
// 方法1: 使用js-cookie 插件
//   在utils目录下新增auth.js 权限验证
import Cookis from 'js-cookie';
const TokenKey = 'elk-token'
function setToken (token) {
    return Cookis.set(TokenKey, token)
}
function getToken () {
    return Cookis.get(TokenKey)
}
function removeToken () {
    return Cookis.remove(TokenKey)
}
export {setToken, getToken, removeToken}
//    在store/modules/user下引入使用
import { setToken, getToken, removeToken } from '@/utils/auth';
// 方法2: 使用vuex-persistedstate 插件
//   在store/index使用
import createPersistedState from 'vuex-persistedstate';
const store =  new Vuex.Store({
  // vuex持久化配置
  plugins: [
    createPersistedState({
      // 写入要持久化保存的数据
      key: 'token',
      paths: ['user.token'] // 只对user模块下的token进行持久化
      // paths: ['user'] // user模块下所有state属性进行持久化
    })
  ]
})
```

### 六、配置全局路由权限

后台管理的访问都需要进行鉴权的，每个路由的访问都是需要对应的权限才能去访问

#### 1、路由配置项「参考vue-element-admin」	

``` javascript
import Vue from 'vue';
import VueRouter from 'vue-router';
import Layout from '@/layout';
Vue.use(VueRouter);
/**
 *  路由配置项
 *  hidden: true                 // 当设置为true的时候，不会出现在侧边导航栏， 比如登录、404这些件界面
 *  redirect: noRedirect         // 当设置为noRedirect的时候，出现的面包屑导航不被点击
 *  name: 'router-name'          // 设置路由的名字，必填并且需跟组件内部name保持一致 比如： views/system/user: user
 *  meta: {
 *    title: 'title'             // 设置该路由在侧边导航栏和面包屑导航中的名字
 *    icon:  'svg-name'          // 设置该路由的图标： path: src/assets/icons/svg下的文件名字
 *    noCache: true              // 当设置为true的时候，不会被keep-alive缓存「默认为false」
 *    affix: true                // 当设置为true的时候，固定在标签栏，不可被删除「默认为false」
 * }
*/
export const constantRoutes = [
  {
    path: '',
    component: Layout,
    redirect: 'index',
    children: [
      {
        path: '/index',
        name: 'Index',
        component: () => import('@/views/index.vue'),
        meta: {
          title: '首页', icon: 'dashboard',noCache: true, affix: true
        }
      }
    ]
  },
  {
    path: '/login',
    component: () => import('@/views/login.vue'),
    hidden: true
  },
  {
    path: '/404',
    component: () => import('@/views/404.vue'),
    hidden: true
  }
]
const router = new VueRouter({
  mode: 'history',
  scrollBehavior: () => { y: 0 }, // 滚动行为，切换路由、回滚到顶部
  routes: constantRoutes
})
export default router
```

#### 2、开启全局前置路由

在 main.js 同级目录创建permission.js文件，来进行全局路由权限的控制

``` javascript
/*
	 开启全局路由的前置守卫 beforeEach(to, from, next)
	 to: 即将进入的路由 from: 当前离开的路由  next: 是个一个方法，一定要调用
	 	1.含有token 
	 		if    如果to.path === '/login' 直接放行
	 		else  role角色权限是否含有
	 				+  有: 获取userInfo、routers
	 				+ 没有: next()
	 	2.没有token
	 		+ to.path 是否在白名单
	 			+ 是 next()
	 			+ 否 重置到登录界面
*/
import Vue from 'vue';
import store from '@/store';
import router from '@/router';
import { Message } from 'element-ui';
const whiteList = ['/login'];     // 白名单
router.beforeEach((to, from, next) => {
    const token = store.getters.token,
        roles = store.getters.roles;
    if (token) {
        if (to.path === '/login') {
            next({ path: '/' })
        } else {
            if (roles.length === 0) {
                store.dispatch("GetInfo").then(() => {
                    store.dispatch("GenerateRouter").then(res => {
                        // 添加routers
                        router.addRoutes(res); 
                        next({ ...to, replace: true });
                    })
                }).catch(err => {
                    store.dispatch("Logout").then(() => {
                        Message.error(err);
                        next({ path: '/' })
                    })
                })
            } else {
                next();
            }
        }
    } else {
        if (whiteList.indexOf(to.path) !== -1) {
            next();
        } else {
            next(`/login?redirect=${encodeURIComponent(to.fullPath)}`)
        }
    }
})
```

### 七、vuex路由权限模块

``` javascript
/*
	路由权限模块-vuex
	这块主要是对后端请求得到的路由列表进行格式转换和储存「前端路由对象、侧边导航栏	 列表」
*/
import { constantRoutes } from "@/router"
import { getRouters } from '@/api/menu';
import Layout from '@/layout/index'
const defaultState = () => {
    return {
        routers: [],        // 前端路对象
        addRouters: [],     // 后端路由列表
        sidebarRouters: [], // 侧边导航栏列表
    }
}
const state = defaultState();
const mutations = {
    SET_ROUTERS: (state, routers) => {
        state.addRouters = routers;
        state.routers = constantRoutes.concat(routers);
    },
    SET_SIDEBARROUTERS: (state, routers) => {
        state.sidebarRouters = constantRoutes.concat(routers);
    }
}
const actions = {
    async GenerateRouter({ commit }) {
        try {
            const routers = await getRouters();
            const rdata = JSON.parse(JSON.stringify(routers.data.routers));
            const sdata = JSON.parse(JSON.stringify(routers.data.routers));
            const formatRdata = formatRouters(rdata);
            const formatSdata = formatRouters(sdata);
            commit('SET_ROUTERS', formatRdata);
            commit('SET_SIDEBARROUTERS', formatSdata);
            return formatRdata;
        } catch (err) {
            return new Error(err)
        }
    }
}
/* 
    将后端路由变成前端路由对象
    遍历后端路由对象，改造成vue-router路由对象
    后端：{
        id: 1,
        title: '系统管理',
        name: 'system',
        path: '/system',
        children:[
            {
                id:2,
                title: '菜单管理',
                name:'menu',
                path:'system/menu',
                link: '/system/menu'
            },
        ]
    }
*/
const formatRouters = function (routers) {
    let routerObj = {
        path: '',
        component: '',
        name: '',
        meta: {},
        children: [],
    }
    return routers.map((router, i) => {
        routerObj = {
            path: router.path,
            name: router.name,
            meta: {
                title: router.title,
                icon: router.icon || '',
                noCache: router.noCache || false
            }
        }
        if (router.link) {
            routerObj.component = loadView(router.link)
        } else {
            routerObj.component = Layout
        }
        if (router.children && router.children.length) {
            routerObj.children = formatRouters(router.children)
        }
        return routerObj;
    })
}
// 路由懒加载配置
const loadView = function (view) {
    return (resolve) => require([`@/views${view}/index`], resolve)
}
export default {
    state,
    mutations,
    actions
}
```

### 八、layout整体布局

​	常规的后台管理布局三大块： 侧边导航栏、顶部navbar以及中间的appMain「内容区」接下来就是对layout文件进行布局模块化，并且在index.vue引入

```javascript
目录结构
layout
  components
     Narbar
     TagsView
     Sidebar
     AppMain.vue
  index.vue
```

```javascript
<template>
    <div class="app-wapper">
        <SideBar/>
        <div class="main-container" :class="sidebar.collapse && 'main-collapse'">
            <div>
                <NavBar />
                <TagsView/>
            </div>
            <AppMain/>
        </div>
    </div>
</template>
<script>
import SideBar from '@/layout/components/Sidebar';
import NavBar from '@/layout/components/Navbar';
import TagsView from '@/layout/components/TagsView';
import AppMain from '@/layout/components/AppMain';

import { mapGetters } from 'vuex';
export default {
    name: 'Layout',
    components: {
        SideBar,
        NavBar,
        TagsView,
        AppMain
    },
    computed: {
        ...mapGetters(['sidebar'])
    },
};
</script>
<style lang="less" scoped>
.app-wapper {
    width: 100%;
    height: 100%;
}
</style>
```

#### 侧边导航栏

​	侧边导航栏这边跟路由是相互挂钩的，请求后端得到对应的路由数据，前端进行数据格式化、vuex存储「vuex路由权限模块」

``` javascript
目录结构
Sidebar
	components
  	Item.vue
		SidebarItem.vue
	Vertical.vue		   「侧边模式」
	Horizontal.vue     「横向模式」
```

##### 1、Vertical.vue

​	侧边导航栏基于element-ui中的el-menu改造而成 「当前是侧边模式」

​	在vuex中拿到改造好的sidebarRouters数据

​	el-scrollbar：用于处理侧边导航栏滚动的问题

```javascript
<template>
  <div class="sidebar-container" :class="formatSidebar">
    <el-scrollbar style="height: 100%" wrap-class="scrollbar-wrapper">
      <el-menu
        router
        :default-active="routeMenu"
        mode="vertical"
        :collapse="sidebar.collapse"
        :unique-opened="false"
        :collapse-transition="false"
        :text-color="formatClass('text')"
        :background-color="formatClass('bg')"
      >
        <sidebar-item
          v-for="(route, index) of sidebarRouters"
          :key="index"
          :item="route"
          :path="route.path"
        ></sidebar-item>
      </el-menu>
    </el-scrollbar>
  </div>
</template>
<script>
import SidebarItem from "@/layout/components/Sidebar/components/SidebarItem";
import { mapGetters } from "vuex";
import variables from "@/style/variable.module.scss";
export default {
  name: "Sidebar",
  components: {
    SidebarItem,
  },
  computed: {
    ...mapGetters(["sidebar", "themeConfig"]),
    routeMenu() {
      const route = this.$route;
      const { path } = route;
      return path;
    },
    sidebarRouters() {
      return this.$store.getters.sidebarRouters.filter((item) => !item.hidden);
    },
    formatClass() {
      const { themeStyle } = this.themeConfig;
      return (type) => {
        switch (themeStyle) {
          case "theme-light":
            return type === "text"
              ? variables.sideBarText
              : variables.sideBarBg;
          case "theme-dead":
            return type === "text"
              ? variables.siderBarDeadText
              : variables.sideBarDeadBg;
          case "theme-dark":
            return type === "text"
              ? variables.siderBarDeadText
              : variables.sideBarDarkBg;
          default:
            return variables.sideBarBg;
        }
      };
    },
    formatSidebar() {
      const { collapse } = this.sidebar;
      if (collapse) {
        return "sidebar-vertical-container sidebar-collapse";
      }
      return "sidebar-vertical-container";
    },
  },
};
</script>
```

##### 2、Horizontal.vue

​	整体思路跟certical一样，只是当前el-meun中的mode属性切换为horizontal

> 这块儿有一点需要注意：当mode设置为horizontal的时候，el-meun中的active-text-color不在是主题色「也不会跟主题色变化而变化」需要自行手动设置这个属性值，mode为vertical时，好像就不需要	

``` javascript
<template>
    <div class="horizontal-container">
        <el-menu
            :default-active="routeMenu"
            mode="horizontal"
            router
            :text-color="formatClass('text')"
            :background-color="formatClass('bg')"
            :active-text-color="themeConfig.themeColor"
        >
            <template v-for="item in sidebarRouters">
                <el-submenu
                    v-if="item.children && item.children.length > 0 && item.redirect === 'noRedirect'"
                    :index="item.path"
                    popper-append-to-body
                    :key="item.path"
                >
                    <template slot="title">
                        <Item v-if="item.meta" :icon="item.meta.icon" :title="formatItem('multi',item.name)" />
                    </template>
                    <sidebar-item 
                        v-for="(route, index) of item.children"
                        :key="index"
                        :item="route"
                        :path="route.path"
                    ></sidebar-item>
                </el-submenu>
                <template v-else>
                    <el-menu-item :index="formatPath(item)">
                        <Item :icon="formatItem('icon', item)" :title="formatItem('title', item)" />
                    </el-menu-item>
                </template>
            </template>
        </el-menu>
    </div>
</template>
<script>
import Item from './components/Item.vue';
import SidebarItem from '@/layout/components/Sidebar/components/SidebarItem';
import variables from '@/style/variable.module.scss';
export default {
    name: 'Horizontal',
    components: {
        Item,
        SidebarItem
    },
    computed: {
        // 当前路由路径
        routeMenu() {
            const route = this.$route;
            const { path } = route
            return path;
        },
        // 匹配布局主题风格样式表
        formatClass() {
            const { themeStyle } = this.themeConfig;
            return (type) => {
                switch (themeStyle) {
                    case 'theme-light':
                        return type === 'text' ? variables.sideBarText : variables.sideBarBg;
                    case 'theme-dead':
                        return type === 'text' ? variables.siderBarDeadText : variables.sideBarDeadBg;
                    case 'theme-dark':
                        return type === 'text' ? variables.siderBarDeadText : variables.sideBarDarkBg;
                    default:
                        return variables.sideBarBg;
                }
            }
        },
        // 布局配置参数
        themeConfig() {
            return this.$store.getters.themeConfig;
        },
        // 过滤侧边导航栏菜单
        sidebarRouters() {
            return  this.$store.getters.sidebarRouters.filter(item => !item.hidden);
        },
    },
    methods: {
        /* 格式化item */
        formatItem(type, item) {
            if (type === 'multi') {
                return this.$formatI18n(this,'menus',item);
            }
            if (item.children) {
                if (type === 'icon') {
                    return item.children[0].meta.icon;
                }
                let title = item.children[0].name;
                return this.$formatI18n(this,'menus',title);
            } else {
                if (type === 'icon') {
                    return item.meta.icon;
                }
                let title = item.name;
                return this.$formatI18n(this,'menus',title);
            }
        },
        /* 格式化path */
        formatPath(item) {
            if (item.redirect) {
                return item.children[0].path
            }
            return item.path
        },
    },
};
</script>
```



##### 3、SidebarItem.vue

​	这个组件来实现渲染单级菜单和多级菜单

​	大概的逻辑就是：在主组件遍历了这个组件并传入每个菜单item，通过props接收这个item，去判断它的children属性

​	含有children属性：配合 el-submenu、 递归当前组件

​	没有children属性：直接跳转到对应路由

> ​	封装这个组件的时候，会遇到mode切换为horizontal的时候，element原始样式失效，导致meun水平样式失效
>
> 当前vue2.6版本使用template模版编译中要求只含义一个父组件包裹，既每个.vue文件template中都有一个div包裹其内部内容，而element内部样式用到了>子代选择器 el-menu > ( el-submenu > el-menu -item ) | el-menu-item > xxx ，当我们这个组件如果使用一个div包裹，可能就是阻断样式，导致样式失效
>
> 目前想到的解决方案有两种：
>
> 	1. 直接用el-submenu 或者 el-menu-item作为父组件包裹内部内容，通过v-if进行切换「是否含有多层菜单，本项目用到的方案」
> 	1. 第二种就是vue的render写法，通过js来实现编写一个组件「函数式组件」，这个不会受那个一个父组件包裹的影响「Item组件有使用」

``` javascript
<template>
  <el-submenu
  v-if="item.children && item.children.length > 0 && item.redirect === 'noRedirect'"
  :index="item.path" popper-append-to-body>
      <template slot="title">
          <Item v-if="item.meta" :icon="item.meta.icon" :title="formatItem('multi',item.name)" />
      </template>
      <sidebar-item v-for="(route, index) of item.children" :key="index" :item="route"
          :path="route.path">
      </sidebar-item>
  </el-submenu>
  <el-menu-item v-else :index="formatPath(item)">
      <Item :icon="formatItem('icon', item)" :title="formatItem('title', item)" />
  </el-menu-item>
</template>
<script>
import Item from './Item.vue';
export default {
    name: 'SidebarItem',
    props: {
        item: Object,
        path: String
    },
    components: {
        Item
    },
    methods: {
        /* 格式化item */
        formatItem(type, item) {
            if (type === 'multi') {
                return this.$formatI18n(this,'menus',item);
            }
            if (item.children) {
                if (type === 'icon') {
                    return item.children[0].meta.icon;
                }
                let title = item.children[0].name;
                return this.$formatI18n(this,'menus',title);
            } else {
                if (type === 'icon') {
                    return item.meta.icon;
                }
                let title = item.name;
                return this.$formatI18n(this,'menus',title);
            }
        },
        /* 格式化path */
        formatPath(item) {
            if (item.redirect) {
                return item.children[0].path
            }
            return item.path
        },

    },
};
</script>
```

##### 4、Item.vue

​	原本这块儿我使用的template语法来渲染图标和标题，但是发现当我在折叠menu的时候，并没有像elementui官网中el-menu示例那样隐藏文字标题，后来通过询问和网上查找得到『`<el-menu>`嵌套中出现了意料之外的`<div>`,而`<el-menu>`标签本身希望里面嵌套的是`<el-menu-item>`,`<el-submenu>`,`<el-menu-item-group>`其中之一』,但是 vue2中的template中内容需要在用一个div包裹着，所以采用了render的方法去挂载渲染，这样单级菜单的文字标题折叠是隐藏了，但是多级菜单并没有，最后没办法了，只能手动去隐藏了

``` javascript
<!-- <template>
    <div>
        <svg-icon :icon-class="icon"></svg-icon>
        <span slot="title">{{ title }}</span>
    </div>
</template> -->
<script>
export default {
    name: 'Item',
    functional: true,
    props: {
        icon:{
            type: String,
            default: ''
        },
        title: {
            type: String,
            default: ''
        }
    },
    render(h, context) {
        const { icon, title } = context.props;
        const vnodes = [];
        if( icon ) {
            vnodes.push(<svg-icon icon-class={icon} />)
        }
        if (title) {
            vnodes.push(<span slot="title">{ title }</span>)
        }
        return vnodes
    }
};
</script>
```

#### 九、顶部navbar

``` javascript
目录结构
Navbar
	components
  	Breadcrumb.vue
		Hamburger.vue
		ScreenFull.vue
		Search.vue
		ThemeConfig.vue
		ToolsMenu.vue
	index.vue
```

​	这块儿目前有三部分组成 hamburger「折叠、展开侧边导航栏按钮」、breadcurmb「面包屑导航」、头像信息「个人中心、布局设置、退出登录」

```javascript
<template>
    <div class="navbar-container">
        <div class="nav-menu">
            <!-- 显隐侧边导航栏图标 -->
            <Hamburger  v-if="themeConfig.layoutStyle === 'vertical'"  />
            <!-- 面包屑导航 -->
            <Breadcrumb v-if="themeConfig.layoutStyle === 'vertical' && themeConfig.isBreadcrumb" />
            <!-- 侧边导航「横向模式」 -->
            <Horizontal v-if="themeConfig.layoutStyle !== 'vertical'" :style="{ backgroundColor: formatStyle  }" />
        </div>
        <div class="nav-menu">
            <!-- 顶部工具类导航 -->
            <ToolsMenu/>
            <!-- 头像和 个人中心、退出登录、布局设置 -->
            <el-dropdown class="avater-container" trigger="hover">
                <div class="avater-wrapper">
                    <img :src="avatar" class="avater-img">
                    <span style="margin: 0 3px 0 0;">{{ name }}</span>
                    <i class="el-icon-caret-bottom" />
                </div>
                <el-dropdown-menu>
                    <el-dropdown-item>首页</el-dropdown-item>
                    <el-dropdown-item>个人中心</el-dropdown-item>
                    <el-dropdown-item divided @click.native="logout">退出登录</el-dropdown-item>
                </el-dropdown-menu>
            </el-dropdown>
        </div>
    </div>
</template>
<script>
import Horizontal from '@/layout/components/Sidebar/Horizontal';
import Hamburger from './components/Hamburger';
import Breadcrumb from './components/Breadcrumb';
import ToolsMenu from './components/ToolsMenu';
import variables from '@/style/variable.module.scss';
import { mapGetters } from "vuex";
export default {
    name: 'Navbar',
    components: {
        Horizontal,
        Hamburger,
        Breadcrumb,
        ToolsMenu
    },
    computed: {
        ...mapGetters(['avatar','name','themeConfig']),
        formatStyle() {
            const { themeStyle } = this.themeConfig;
            switch (themeStyle) {
                case 'theme-light':
                    return variables.sideBarBg;
                case 'theme-dead':
                    return variables.sideBarDeadBg;
                default:
                return variables.sideBarBg;
            }
        }
    },
    methods: {
        /* 退出登录 */
        logout() {
            this.$confirm('确定要注销退出系统吗？','提示', {
                type: 'warning'
            }).then( () => {
                this.$store.dispatch("Logout").then( res => {
                    if (res.code === 200) {
                        location.href = "/index"
                    }
                })
            })
        }   
    },
};
</script>
<style lang="scss" scoped>
.navbar-container {
    width: 100%;
    height: 50px;
    background-color: #fff;
    transition: background-color .3s;
    overflow: hidden;
    box-shadow: 0px 1px 4px rgba(0, 21, 41, 0.08);
    display: flex;
    align-items: center;
    justify-content: space-between;
    .nav-menu {
        display: flex;
        align-items: center;
        height: 100%;
    }
    .avater-container {
        padding:0 10px;
        .avater-wrapper {
            display: flex;
            align-items: center;
            .avater-img {
                cursor: pointer;
                width: 25px;
                height: 25px;
                border-radius: 100%;
                margin-right: 5px;
            }
        }
    }
}
</style>
```

##### 1、Hamburger「折叠、展开侧边导航按钮」

​	el-menu中有个collapse属性来控制侧边导航栏的折叠和展开，将这个数值存储在vuex中，通过mutations、 acutions去修改这个数值，实时动态改变这个值

``` javascript
<template>
    <div @click="changeIcon" class="hamburger-container">
        <i class="icon-class" :class="formatIcon"></i>
    </div>
</template>
<script>
import { mapGetters } from 'vuex';
export default {
    name: 'Hamburger',
    computed: {
        ...mapGetters(['sidebar']),
        /* el-icon-s-fold   el-icon-s-unfold */
        formatIcon() {
            if( this.sidebar.collapse) {
                return 'el-icon-s-unfold'
            }
            return 'el-icon-s-fold'
        }
    },
    methods: {
        changeIcon() {
            this.$store.dispatch("changeCollapse")
        }
    },
};
</script>
<style lang="less" scoped>
.hamburger-container {
    float: left;
    line-height: 50px;
    font-size: 20px;
    &:hover{
        background-color: rgba(0, 0, 0, 0.025);
    }
    .icon-class {
        padding: 0 15px;
    }
}
</style>
```

##### 2、breadcrumb「面包屑导航」

​	结合el-breadcrumb组件来实现面包屑导航功能

​	监听当前路由的metched属性获得路由信息	

``` javascript
<template>
    <el-breadcrumb class="breadcrumb-container" separator="/">
        <transition-group name="breadcrumb">
            <el-breadcrumb-item v-for="(item, index) in pathList" :key="index">
                <span v-if="item.redirect == 'noRedirect' || index == pathList.length - 1" class="no-redirect">{{
                    item.meta.title }}</span>
                <a v-else @click.prevent="handelLink(item)">{{ item.meta.title }}</a>
            </el-breadcrumb-item>
        </transition-group>
    </el-breadcrumb>
</template>
<script>
export default {
    name: 'Breadcrumb',
    watch: {
        $route(route) {
          	// 排除重定向路径
          	if (route.path.startswWith("/redirect/")) {
              return
						}
            this.getBreadcrumbList();
        }
    },
    mounted() {
        this.getBreadcrumbList();
    },
    methods: {
        /* 获取面包屑列表*/
        getBreadcrumbList() {
            let matcheds = this.$route.matched.filter(item => item.meta && item.meta.title);
            const start = matcheds[0];
            let home = [{ path: '/index', meta: { title: '首页' } }];

            if (start.meta.title !== '首页') {
                matcheds = home.concat(matcheds);
            }
            this.pathList = matcheds;

        },
        /* a标签跳转指定路由 */
        handelLink(item) {
            const { path } = item;
            this.$router.push({ path })
        }
    },
};
</script>
```

##### 3.toolsMenu「工具导航」

这块主要是一些工具菜单：：组件大小、搜索、语言切换、全屏、布局配置、个人信息(头像、姓名)

整体配置都存在vuex中：@/store/modules/toolsmenu.js

代码：@/layout/components/Navbar/components/ToolsMenu.vue

###### 1.组件大小

 	代码：@/layout/components/Navbar/components/ToolsMenu.vue

``` javascript
<!-- 组件大小部分 -->
<el-dropdown @command="touchCommand($event, 'componentSize')" trigger="click" class="menu-height hover-effect">
    <div>
        <svg-icon icon-class="size" />
    </div>
    <el-dropdown-menu>
        <el-dropdown-item command="default" :disabled="componentSize === 'default'">{{ $t('toolsMenus.default') }}</el-dropdown-item>
        <el-dropdown-item command="medium" :disabled="componentSize === 'medium'">{{ $t('toolsMenus.medium') }}</el-dropdown-item>
        <el-dropdown-item command="small" :disabled="componentSize === 'small'">{{ $t('toolsMenus.small') }}</el-dropdown-item>
        <el-dropdown-item command="mini" :disabled="componentSize === 'mini'">{{ $t('toolsMenus.mini') }}</el-dropdown-item>
    </el-dropdown-menu>
</el-dropdown>
<!-- main.js：配合vuex 切换el组件size -->
Vue.use(ElementUI, {
  size: store.getters.componentSize | 'medium'
});
```

###### 2. 搜索

​	结合el-dialog和el-autocomplete组件来实现

​	代码：@/layout/components/Navbar/components/Search.vue

​	主要涉及到的逻辑：

​		1.处理路由的格式，转化成autocomplete可用的格式

​		2.搜索事件：输入内容和列表内容的正则匹配，筛选出含有输入内容的数据

``` javascript
/* 格式化菜单内容 */
formatList(sidebarRouters) {
    sidebarRouters.forEach(item => {
        let obj = {};
        if (item.redirect === 'index') {
            obj.value = item.children[0].name;
            obj.path = item.children[0].path;
            this.searchList.push(obj);
        }
        if (item.meta) {
            if (item.children) {
                obj.value = item.name;
                obj.path = item.children[0].path;
                this.searchList.push(obj);
                this.formatList(item.children);
            } else {
                obj.value = item.name;
                obj.path = item.path;
                this.searchList.push(obj);
            }
        }
    })
}
/* 搜索事件 */
querySearch(queryString, cb) {
    /* 
        拿到queryString,用户输入的内容
        循环正则匹配formatRouters中的每一项的name跟queryString是否匹配，检索出来
    */
    let query = queryString.trim();
    let searchList = this.searchList;
    let searchs = query ? this.searchListFilter(query, searchList) : searchList;
    cb(searchs);
},
```

###### 3. 语言切换「国际化」

​	采用 vue-i18n@8插件实现

​	目录： @/lang/inddex.js | en.js | zh.js 「index.js为主文件，其他语音分别创建不同的.js文件，保证属性名一样即可」

``` javascript
// 1. index.js
import Vue from 'vue';
import VueI18n from 'vue-i18n';
import store from '@/store';
import Elementui from 'element-ui';
Vue.use(VueI18n);
// 引入中英js文件
import Chinese from './zh';
import English from './en';
// 创建i18n实列
const i18n = new VueI18n({
    locale: store.getters.languageType,  // 设置i18n语言
    messages: {
        'zh-cn': Chinese,
        'en': English,
    },
    silentFallbackWarn: true,  // 设置为true后，在组件内使用时在浏览器不会报警告
})
Vue.use(Elementui, {
    i18n: (key, value) => i18n.t(key, value)
})
export default i18n;
// 2. en.js | zh.js | 其他语音.js
import zhLocale from 'element-ui/lib/locale/lang/zh-CN'; // elementui中文包
export default {
    /* 侧边导航栏 */
    menus: {
        Index: '首页',
        system: '系统管理',
        Menu: '菜单管理',
        User: '用户管理',
        Role: '角色管理',
        monitor: '系统监控',
        Online: '在线用户'
    },
    /* 布局设置 */
    toolsMenus: {
        title: '布局设置',
        themeStyle: '主题风格',
        themeColor: '主题颜色',
        isBreadcrumb: '是否显示面包屑',
        isTagsviews: '是否显示标签栏',
        isHeader: '是否固定头',
        layoutStyle: '布局样式'
    },
    ...zhLocale,
}
// 3. 将 i18n 挂载到实例上 「main.js」
import i18n from './lang';
new Vue({
  i18n,
  render: h => h(App)
}).$mount('#app')
```

``` javascript
// 使用方法
// 1. <template>中使用
		<span>$t('模块名.属性名「key」')</span>  
		// 例如上方： $('menus.Index');  // 首页 | home
// 2. script中使用
	this.$t('模块名.属性名');
// 3. 利用vuex进行持久化切换的时候
  		// 更新i18n中的语言
    	this.$i18n.locale = command;
```

###### 4. 布局配置

​	当前布局配置：主题风格「淡色、暗色、暗黑」，主题颜色「自定义」，面包屑、标签栏的显示隐藏，头部是否固定，布局样式「侧边、顶部」这六种配置

​	代码： @/layout/components/Navbar/components/ThemeConfig.vue

``` javascript
<template>
    <div class="theme-config-container">
        <el-drawer destroy-on-close :title="formatI18n('title')" :visible="isThemeConfig" :size="300" direction="rtl" :show-close="true"
            @close="closeDrawer">
            <!-- 主题风格 -->
            <div class="theme-style">
                <span class="theme-item-title">{{ formatI18n('themeStyle') }}</span>
                <div @click="handelSvg($event, 'themeStyle')" class="theme-svg">
                    <svg-icon icon-class="theme-light"></svg-icon>
                    <svg-icon icon-class="theme-dead"></svg-icon>
                    <svg-icon icon-class="theme-dark"></svg-icon>
                    <span :style="formatStyle('style')" class="svg-active">✔️</span>
                </div>
            </div>
            <!-- 主题颜色 -->
            <div class="theme-item">
                <span class="theme-item-title">{{ formatI18n('themeColor') }}</span>
                <theme-picker @change="handelTheme" />
            </div>
            <!-- 界面展示 -->
            <div class="theme-list">
                <div class="theme-item">
                    <span class="theme-item-title">{{ formatI18n('isBreadcrumb') }}</span>
                    <el-switch v-model="themeConfig.isBreadcrumb" @change="handelTheme($event, 'isBreadcrumb')"></el-switch>
                </div>
                <div style="margin: 20px 0;" class="theme-item">
                    <span class="theme-item-title">{{ formatI18n('isTagsviews') }}</span>
                    <el-switch :disabled="themeConfig.layoutStyle === 'horizontal'" v-model="themeConfig.isTagsviews" @change="handelTheme($event, 'isTagsviews')"></el-switch>
                </div>
                <div class="theme-item">
                    <span class="theme-item-title">{{ formatI18n('isHeader') }}</span>
                    <el-switch v-model="themeConfig.isHeader" @change="handelTheme($event, 'isHeader')"></el-switch>
                </div>
            </div>
            <!-- 布局样式 -->
            <div class="theme-style">
                <span class="theme-item-title">{{ formatI18n('layoutStyle') }}</span>
                <div @click="handelSvg($event, 'layoutStyle')" class="theme-svg">
                    <svg-icon icon-class="vertical"></svg-icon>
                    <svg-icon icon-class="horizontal"></svg-icon>
                    <span :style="formatStyle('layout')" class="svg-active">✔️</span>
                </div>
            </div>
        </el-drawer>
    </div>
</template>
<script>
import ThemePicker from '@/components/ThemePicker';
import { mapGetters } from "vuex";
export default {
    name: 'ThemeConfig',
    components: {
        ThemePicker
    },
    computed: {
        ...mapGetters(['themeConfig', 'isThemeConfig']),
        /* 主题样式选中切换 */
        formatStyle() {
            return (type) => {
                const { themeStyle, layoutStyle } = this.themeConfig;
                if (type === 'style') {
                    switch (themeStyle) {
                        case 'theme-light':
                            return 'left: 30px';
                        case 'theme-dead':
                            return 'left: 90px';
                        case 'theme-dark':
                            this.changeDark(themeStyle, 'themeStyle');
                            return 'left: 150px';
                        default:
                            return 'left: 30px';
                    }
                } else {
                    switch (layoutStyle) {
                        case 'vertical':
                            return 'left: 30px';
                        case 'horizontal':
                            return 'left: 90px';
                        default:
                            return 'left: 30px';
                    }
                }
            }
        },
        /* i18n格式化 */
        formatI18n() {
            return (key) => {
                return this.$formatI18n(this, 'themeConfig', key);
            }
        }
    },
    methods: {
        /* 关闭drawer */
        closeDrawer() {
            this.$store.dispatch("setToolsMenu", {
                key: 'isThemeConfig',
                value: false
            })
        },
        /* 主题切换事件 */
        handelTheme(value, key) {
            if( value === 'horizontal' && this.$store.getters.sidebar.collapse) {
                this.$store.dispatch('changeCollapse')
            }
            this.$store.dispatch('setThemeConfig', {
                key,
                value
            });
        },
        /* svg点击事件 */
        handelSvg(e, type) {
            const { target } = e;
            const name = target.getAttribute('xlink:href');
            if (name) {
                const newName = name.replace('#icon-', '');
                this.handelTheme(newName, type);
                this.changeDark(newName, type);
            }
        },
        /* 暗黑主题切换 */
        changeDark(val, type) {
            let html = document.documentElement;
            if (type === 'themeStyle' && val === 'theme-dark') {
                html.classList.add("dark");
            } else {
                html.classList.remove("dark");
            }
        }
    },
};
</script>
```

###### 5.个人信息

​	包含：头像、用户名以及下拉菜单「首页、个人中心、退出登录」

​	代码：@/layout/components/Navbar/index.vue  「未拆分组件」

``` javascript
<!-- 头像和 个人中心、退出登录、布局设置 -->
<el-dropdown class="avater-container" trigger="hover">
    <div class="avater-wrapper">
        <img :src="avatar" class="avater-img">
        <span style="margin: 0 3px 0 0;">{{ name }}</span>
        <i class="el-icon-caret-bottom" />
    </div>
    <el-dropdown-menu>
        <el-dropdown-item>首页</el-dropdown-item>
        <el-dropdown-item>个人中心</el-dropdown-item>
        <el-dropdown-item divided @click.native="logout">退出登录</el-dropdown-item>
    </el-dropdown-menu>
</el-dropdown>
```

#### 十、标签栏导航tagsview

​	快捷导航栏：可以更加方便的访问之前从侧边导航栏访问的界面，每点一个标签都会跳转到对应的路由中去，通过监听$route的变化，配合keep-alive来判断当前界面是重新加载还是已经被缓存了 ，采取的方案也是借鉴了「vue-element-admin」

代码： @/views/layout/components/AppMain.vue

``` javascript
/*
	* 主要代码
		include： 字符串和正则表达式，只有名称匹配的组件会被缓存
*/
<keep-alive :include="cacheViews">
    <router-view />
</keep-alive>
computed:{
    cacheViews() {
        return this.$store.getters.cacheViews
    }
}
```

代码：@/views/layout/components/TagsView/index.vue

##### 1. index.vue

​	标签栏导航：采用el-tabs标签页组件

​	鼠标右击下拉菜单：手写的ul>li标签，通过v-show来实现显隐

``` javascript
<template>
    <div class="tags-container">
        <el-scrollbar style="width: 100%;">
            <el-tabs v-model="tabsValue" type="card" @tab-remove="removeTab" @tab-click="clickTab"
                @contextmenu.prevent.native="openDropdown($event)">
                <el-tab-pane v-for="(tag, index) of visitedViews" :key="tag.name"
                    :closable="tag.name !== 'Index' && !tag.meta.affix" :label="tag.meta.title" :name="tag.path">
                </el-tab-pane>
            </el-tabs>
        </el-scrollbar>
        <!-- 鼠标右击出现4个选项 -->
        <ul v-show="hideDropdown" :style="`top: ${top}px; left: ${left}px`" class="contextDropdown">
            <li @click="refreshCurrentTag(selectedTag)"><i class="el-icon-refresh-right" />刷新当前</li>
            <li v-if="!isAffix(selectedTag)" @click="closeCurrentTag(selectedTag)"><i class="el-icon-close" />关闭当前</li>
            <li @click="closeOtherTag(selectedTag)"><i class="el-icon-minus" />关闭其他</li>
            <li @click="closeAllTag(selectedTag)"><i class="el-icon-folder-delete" />关闭全部</li>
        </ul>
    </div>
</template>
<script>
import { mapGetters } from 'vuex';
export default {
    name: 'TagsView',
    computed: {
        ...mapGetters(['visitedViews', 'routers']),
    },
    data() {
        return {
            tabsValue: '/index',   // tags标签选中值「采用的path」
            hideDropdown: false,   // tags下拉选项隐藏值
            selectedTag: {},       // 右击选中的tag
            left: 0,
            top: 0
        }
    },
    watch: {
       	/* 监听route：tabs标签选中值切换、改变标签栏列表数据 */
        $route(route) {
            const { path } = route
            this.tabsValue = path;
            this.addTags();
        },
        /* 监听下拉选择隐藏值：动态绑定、移除closeDropdown事件 */
        hideDropdown(show) {
            if (show) {
                document.body.addEventListener("click", this.closeDropdown);
            } else {
                document.body.removeEventListener("click", this.closeDropdown);
            }
        }
    },
    mounted() {
        this.initTags();
        this.addTags();
    },
    methods: {
        /* 添加tagsview和cacheview */
        addTags() {
            const { name } = this.$route;
            if (name) {
                this.$store.dispatch('addView', this.$route);
            }
            return false
        },
        /* 初始化同步tabs标签标题 */
        initTags() {
            const { name, path } = this.$route;
            const indexTags = this.routers[0].children[0];
            if (name !== '/index') {
                this.$store.dispatch("addVisitedView", indexTags);
                this.tabsValue = path;
            }
        },
        /* 是否固定在标签栏导航中 */
        isAffix(tag) {
            return tag.meta && tag.meta.affix
        },
        /* tags标签点击按钮 */
        clickTab(instance) {
            const { name: path } = instance;
            if (path !== this.$route.path) {
                this.$router.push({ path });
            }
        },
        /* tags标签删除按钮 */
        removeTab(path) {
            const filterTags = this.visitedViews.filter(item => item.path === path)[0];
            this.removeTag(filterTags);
        },
        /* 删除tag */
        removeTag(tag) {
            this.$store.dispatch('delView', tag).then(() => {
                this.toLastView(tag);
            });
        },
        /* 关闭标签后的路由跳转 */
        toLastView(tag) {
            /* 获取最后一个tag并跳转 */
            const endTag = this.visitedViews.slice(-1)[0];
            if (endTag) {
                endTag.path !== this.$route.path && this.$router.push({ path: endTag.path });
            } else {
                this.$router.push("/")
            }
        },
        /* 右击打开dropdown菜单 */
        openDropdown(event) {
            const { target: { id, innerText } } = event;
            // 最大宽度
            const dropdownMinWidth = 105;
            // 获取当前元素距离浏览器左边的距离
            const offsetLeft = this.$el.getBoundingClientRect().left;
            // 当前容器的宽度
            const offsetWidth = this.$el.offsetWidth;
            // 设置菜单出现的边界
            const maxLeft = offsetWidth - dropdownMinWidth;
            const left = event.clientX - offsetLeft;
            // 距离左侧位置的偏移量
            if (left > maxLeft) {
                this.left = maxLeft;
            } else {
                this.left = left;
            }
            // 距离顶部位置的偏移量
            this.top = event.clientY + 20;
            // 获取当前点击的tag
            this.filterCurrentTag(id, innerText);
            // 打开 菜单栏
            this.hideDropdown = true;
        },
        /* 获取当前右键的tags */
        filterCurrentTag(path, title) {
            let nPath = path.replace('tab-', '');
            this.selectedTag = this.visitedViews.filter(item => item.path === nPath && item.title === title)[0];
        },
        /* 关闭dropdown下拉菜单 */
        closeDropdown() {
            this.hideDropdown = false;
        },
        /* 刷新当前标签 */
        refreshCurrentTag(tag) {
            this.$store.dispatch("delCacheView", tag).then( () => {
                this.$nextTick( () => {
                    this.$router.replace({
                        path: '/redirect' + tag.path
                    })
                })
            })
        },
        /* 关闭当前标签 */
        closeCurrentTag(tag) {
            this.removeTag(tag);
        },
        /* 关闭其他标签 */
        closeOtherTag(tag) {
            this.$store.dispatch("closeOtherView", tag).then(() => {
                this.toLastView(tag);
            });
        },
        /* 关闭全部标签 */
        closeAllTag(tag) {
            this.$store.dispatch("closeAllView").then(() => {
                this.toLastView(tag);
            });
        }
    },
};
</script>
<style lang="less" scoped>
.tags-container {
    width: 100%;
    height: 35px;
    padding-left: 10px;
    padding-top: 3px;
    background: #fff;
    border-bottom: 1px solid #d8dce5;
    box-shadow: 0px 1px 3px 0 rgba(0, 0, 0, .12), 0px 0px 3px 0px rgba(0, 0, 0, .04);
    .tags-wappar {
        display: flex;
        align-items: center;
    }
    /* el-tabs 内部样式修改 */
    & /deep/ .el-tabs__item {
        height: 30px !important;
        line-height: 30px !important;
        font-weight: 400;
    }
    & /deep/ .el-tabs--card>.el-tabs__header {
        border-bottom: none;
    }
    .contextDropdown {
        margin: 0;
        background: #fff;
        z-index: 3000;
        position: absolute;
        list-style-type: none;
        padding: 5px 0;
        border-radius: 4px;
        font-size: 12px;
        font-weight: 400;
        color: #333;
        box-shadow: 2px 2px 3px 0 rgba(0, 0, 0, .3);
        li {
            margin: 0;
            padding: 7px 16px;
            cursor: pointer;
            &:hover {
                background: #eee;
            }
        }
    }
}
</style>
```

##### 2. tagsview.js「[SortableJS](https://www.itxst.com/sortablejs/neuinffi.html)」

通过vuex来管理visitedViews和cacheViews这两个数据

统一控制标签栏导航中tag的新增、删除等逻辑

代码：@/store/moudles/tagsview.js

``` javascript
const defaultState = () => {
    return {
        visitedViews: [],      // 访问过的tags路由
        cacheViews: []         // 需要缓存的路由
    }
}
const state = defaultState();
const mutations = {
    /**  
     * 需排除重复添加的数据的情况
     * 将view和{title: xxx}合并到一个新的空对象push到visitedViews中
    */
    ADD_VISITED_VIEW: (state, view) => {
        if (state.visitedViews.some((item) => item.path === view.path)) return
        state.visitedViews.push(
            Object.assign({}, view, {
                title: view.meta.title || 'no-name'
            })
        )
    },
    /**
     * includes：判断cacheViews数组中是否含有这个值，防止重复添加
     * 将开启缓存的组件的name添加到cacheViews中去
     */
    ADD_CACHE_VIEW: (state, view) => {
        if (state.cacheViews.includes(view.name)) return
        if (!view.meta.noCache) {
            state.cacheViews.push(view.name)
        }
    },
    UPDATE_VISITED_VIEW: (state, view) => {
        state.visitedViews = [];
        state.visitedViews.push(
            Object.assign({}, view, {
                title: view.meta.title || 'no-name'
            })
        )
    },
    /* 
        state.visitedViews = state.visitedViews.filter( item => item.name !== view.name );
        state.visitedViews.splice(state.visitedViews.indexOf(view),1);
        直接使用这两种方法时删除，如果删除前面、中间的tags出现了下面错误
            Duplicate keys detected: 'tab-/system/role'. This may cause an update error
            经过排查发现是 TagsView组件中el-tab-pane for循环 key使用的index会出现，换成其他唯一标识即可
    */
    DEL_VISITED_VIEW: (state, view) => {
        state.visitedViews.splice(state.visitedViews.indexOf(view.name), 1);
    },
    DEL_CACHE_VIEW: (state, view) => {
        state.cacheViews.splice(state.cacheViews.indexOf(view.name), 1);
    },
    /* 移除其他visited：将这个view和固定在标签「affix为true」的过滤出来并重新赋值给visitedViews即可 */
    DEL_OTHER_VISITED_VIEW: (state, view) => {
        state.visitedViews = state.visitedViews.filter( v => v.meta.affix || v.path === view.path)
    },
    /* 移除其他cache */
    DEL_OTHER_CACHE_VIEW: (state, view) => {
        state.cacheViews = state.cacheViews.filter( v => v.meta.affix || v.path === view.path)
    },
    /* 移除全部visited: 过滤出固定在标签「affix为true」重新赋值给visitedViews */
    DEL_ALL_VISITED_VIEW: (state,view) => {
        state.visitedViews = state.visitedViews.filter( v => v.meta.affix)
    },
    /* 移除全部cache */
    DEL_ALL_CACHE_VIEW: (state,view) => {
        state.cacheViews = [];
    }
};
const actions = {
    addView({ dispatch, commit }, view) {
        commit("ADD_VISITED_VIEW", view);
        commit("ADD_CACHE_VIEW", view);
    },
    addVisitedView({ commit }, view) {
        commit("ADD_VISITED_VIEW", view);
    },
    delView({ commit }, view) {
        return new Promise( resolve => {
            commit("DEL_VISITED_VIEW", view);
            commit("DEL_CACHE_VIEW", view);
            resolve();
        })
    },
    delVisitedView({ commit }, view) {
        commit("DEL_VISITED_VIEW", view)
    },
    delCacheView({commit}, view) {
        return new Promise ( resolve => {
            commit("DEL_CACHE_VIEW", view);
            resolve();
        })
    },
    upVisitedView({ commit }, view) {
        commit("UPDATE_VISITED_VIEW", view);
    },
    closeOtherView({dispatch,commit},view) {
        return new Promise( resolve => {
            commit("DEL_OTHER_VISITED_VIEW",view);
            commit("DEL_OTHER_CACHE_VIEW",view);
            resolve();
        })
    },
    closeAllView({dispatch,commit},view) {
        return new Promise( resolve => {
            commit("DEL_ALL_VISITED_VIEW");
            commit("DEL_ALL_CACHE_VIEW");
            resolve();
        })  
    },
}
export default {
    state,
    mutations,
    actions
}
```

#### 十一、中心appMain

​	中心内容区比较容易理解，当切换路由的时候，router-view会去渲染匹配到的视图组件，当我们切换路由的时候，这块儿就会展示对应路由的内容

```javascript
<template>
    <div class="app-main">
        <transition>
            <keep-alive :include="cacheViews">
                <router-view />
            </keep-alive>
        </transition>
    </div>
</template>
<script>
export default {
    name: 'AppMain',
    computed:{
        cacheViews() {
            return this.$store.getters.cacheViews
        }
    }
};
</script>
```





